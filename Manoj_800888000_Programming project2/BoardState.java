import java.util.*;

/*
 * BoardState class maintains the chess board by generating the successors of the current board
 * and their corresponding heuristics
 */
public class BoardState implements Comparable<BoardState>{
	private final int qCount; //queens count
	public QueenState[] queenPosition; //queens positions in the board
	public  ArrayList<BoardState> successorBoards;
	private int heuristicValue; //heuristics

	/*
	 * Constructor for generating the initial state of queen board
	 */
	public BoardState(int queens)
	{

		successorBoards = new ArrayList<BoardState>();
		qCount = queens;
		queenPosition = new QueenState[qCount];
	} 

	/*
	 * Constructor for generating the successors queen boards of the initial queen board
	 */
	public BoardState(BoardState board, int queens)
	{

		successorBoards = new ArrayList<BoardState>();
		qCount = queens;
		queenPosition = new QueenState[qCount];
		for(int i=0; i<qCount; i++){
			int row = board.queenPosition[i].getqueenRow();
			int col = board.queenPosition[i].getqueenCol();
			queenPosition[i] = new QueenState(row, col);
		}

		heuristicValue=0;//initialize 
	}

	/**
	 * This method generates the successor boards with corresponding queen states and its heuristics
	 * depending on the start state
	 * The successor board is generated by shifting the queens downwards for different columns 
	 */
	public ArrayList<BoardState> successorBoard(BoardState initialBoard)
	{
		int count=0;//index counter for the current board successors

		for(int qPos=0; qPos<qCount; qPos++){
			for(int rowShift=1; rowShift<qCount; rowShift++)//shift the row position of queen by rowShift
			{

				BoardState st = new BoardState(initialBoard,qCount);
				successorBoards.add(count,st);
				successorBoards.get(count).queenPosition[qPos].shiftQueen(rowShift,qCount);
				successorBoards.get(count).heuristicEvaluation();//calculates the heuristics of the successor
				count++;
			}
		}

		return successorBoards;
	}


	/**
	 * This method calculate the heuristics of the current board and 
	 * the heuristic value is taken as number of queens attacking each other or 
	 * the number of conflicts.
	 * 
	 */
	public int heuristicEvaluation()
	{

		for(int i=0; i<qCount-1; i++){
			for(int j=i+1; j<qCount; j++){
				if(queenPosition[i].isConflicting(queenPosition[i],queenPosition[j]))
					//Compares the queen in a column with all the queens in the columns right of it.
				{
					heuristicValue++; //Increments the heuristics when ever a conflict is found
				}
			}
		}

		return heuristicValue;
	}


	public int getheuristicValue(){
		return heuristicValue;
	}

	/**
	 * This method compares the heuristics of current board with the other or successor boards
	 */
	public int compareTo(BoardState board)
	{
		if(this.heuristicValue < board.getheuristicValue())
			return -1;
		else if(this.heuristicValue > board.getheuristicValue())
			return 1;
		else 
			return 0;
	}


	public void setqueenPosition(QueenState[] state)
	{
		for(int i=0; i<qCount; i++){
			int row = state[i].getqueenRow();
			int col = state[i].getqueenCol();
			queenPosition[i]= new QueenState(row, col);
		}
	}


	public QueenState[] getqueenPosition()
	{
		return queenPosition;
	}

	/*
	 * This method constructs and prints the 2D N-queen board  
	 */
	public String toString()
	{
		String[][] chessboard2D = new String[qCount][qCount];
		String output = "";

		for(int i=0; i<qCount; i++)
			for(int j=0; j<qCount; j++)
				chessboard2D[i][j]="0"; //Initialize the chess board to 0's

		//place the queens on the board
		for(int i=0; i<qCount; i++){
			// sets a square of 2D chess board to "1" if queen is found in the corresponding index of board state
			// "1" indicate the presence of queen
			int row = queenPosition[i].getqueenRow();
			int col = queenPosition[i].getqueenCol();
			chessboard2D[row][col]="X";
		}

		//constructs the output string which is to be printed
		for(int i=0; i<qCount; i++){
			for(int j=0; j<qCount; j++){
				output+= " "+chessboard2D[i][j];
			}
			output+="\n";
		}

		return output;
	}
}
